# **SmartLogger**: Logging Framework – Functional Requirements

These contain the core logging operations which are as follows:

---

## 1. Log Levels with Priority System

Support 5 log levels: **DEBUG, INFO, WARNING, ERROR, FATAL**
Each level has a priority:

* DEBUG = 1
* INFO = 2
* WARNING = 3
* ERROR = 4
* FATAL = 5

Only log messages with priority **≥ configured level**.

Example:

```csharp
logger.SetLevel(LogLevel.WARNING);

logger.Debug("This won't be logged");    // Skipped
logger.Info("This won't be logged");     // Skipped
logger.Warning("This will be logged");   // Logged
logger.Error("This will be logged");     // Logged
```

---

## 2. Log Message Structure

Each log message contains the following fields:

* **Timestamp**: When the log was created
* **Level**: Severity of the message
* **Message**: Description of what happened
* **Source**: Class or method generating the log (optional)
* **Correlation ID**: Identifier used to trace a request across threads or services (optional, auto-generated if not provided)

---

## 3. Multiple Output Destinations

Support multiple output destinations (sinks):

* **Console**: Display logs in terminal/console (development)
* **File**: Persist logs to files (production)
* **Database**: Store logs for querying and analysis

A single log message **can be written to multiple destinations simultaneously**.

Each destination operates independently to avoid blocking other sinks.

---

## 4. Configuration System

Provide a simple configuration mechanism to:

* Set logging level for the entire application
* Enable or disable specific output destinations
* Configure message formatting rules
* Configure correlation ID behavior
* Configure overload handling policies

Configuration must be readable and modifiable at runtime without restarting the application.

---

## 5. Thread Safety

The logging framework must be fully thread-safe:

* Multiple threads can log concurrently
* No message loss due to race conditions
* No interleaving or corruption of log messages
* All shared components (queues, formatters, sinks) are thread-safe

---

## 6. Extensibility

The framework must be easily extensible:

* New output destinations can be added without modifying core logic
* New log levels can be introduced if required
* Custom message formatters can be plugged in
* Correlation strategies can be customized

---

## 7. Custom Message Formatting

Allow customization of how log messages appear:

* Configurable timestamp formats
* Custom level representations
* Structured or plain-text layouts
* Different formatting rules per output destination

---

## 8. Correlation Context Management (Differentiator)

The framework must support **first-class correlation context**:

* Correlation ID can be explicitly set by the application
* Correlation ID is automatically propagated across threads
* A correlation ID is generated automatically if not provided
* Correlation context is included in every log message

Example:

```charp
logger.WithCorrelation("req-123", () => {
    logger.Info("Processing request");
});
```

---

## 9. Overload Protection & Log Drop Strategy (Differentiator)

The framework must protect the application during high logging volume:

* Log messages are processed using an internal queue
* Maximum queue size is configurable
* When the queue is full, a configurable drop strategy is applied:

Supported strategies:

* Drop low-priority logs first (DEBUG, INFO)
* Sample logs instead of logging all
* Always retain ERROR and FATAL logs

The framework must track and expose the number of dropped log messages.

---

## 10. Logging Failure Visibility & Health Monitoring (Differentiator)

The framework must expose visibility into its own health:

* Track failures for each output destination
* Track dropped log messages due to overload
* Track last successful write time per destination

Provide hooks or callbacks for:

* Sink failure events
* Repeated logging failures
* Logging pipeline degradation

This allows applications to detect when logging is not functioning correctly.

---

# **SmartLogger**: Logging Framework – Non-Functional Requirements

* **Thread Safety**: Handle concurrent logging without data corruption
* **Performance**: Minimal overhead on application threads
* **Extensibility**: Easy to add new log levels and destinations
* **Configurability**: Support runtime configuration updates
* **Memory Efficiency**: Bounded memory usage even under heavy load
* **Resilience**: Failure of one output destination must not affect others

---

# Few Edge Cases to Consider

* Multiple threads logging simultaneously to the same destination
* Invalid log levels or misconfiguration
* File system full or file access failure during file logging
* Database connection failure during database logging
* Logging queue overflow under high load
* Correlation context loss in asynchronous execution paths

---